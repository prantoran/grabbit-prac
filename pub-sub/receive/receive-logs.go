package main

import (
	"fmt"
	"log"

	"github.com/streadway/amqp"
)

func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf("%s: %s", msg, err)
		panic(fmt.Sprintf("%s: %s", msg, err))
	}
}

func main() {
	conn, err := amqp.Dial("amqp://lori:lori@localhost:5672/")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	err = ch.ExchangeDeclare(
		"logs",   // name
		"fanout", // type
		true,     // durable
		false,    // auto-deleted
		false,    // internal
		false,    // no-wait
		nil,      // arguments
	)
	failOnError(err, "Failed to declare an exchange")

	/*
	   Temporary queues
	   As you may remember previously we were using queues
	   which had a specified name (remember hello and task_queue?).
	   Being able to name a queue was crucial for us -- we needed
	   to point the workers to the same queue. Giving a queue a name
	   is important when you want to share the queue between
	   producers and consumers.

	   But that's not the case for our logger. We want to hear
	   about all log messages, not just a subset of them. We're also
	   interested only in currently flowing messages not in the old
	   ones. To solve that we need two things.

	   Firstly, whenever we connect to Rabbit we need a fresh,
	   empty queue. To do this we could create a queue with a random
	   name, or, even better - let the server choose a random queue name for us.

	   Secondly, once we disconnect the consumer the queue should be
	   automatically deleted.

	   In the amqp client, when we supply queue name as an empty
	   string, we create a non-durable queue with a generated name:
	*/
	q, err := ch.QueueDeclare(
		"",    // name
		false, // durable
		false, // delete when usused
		true,  // exclusive
		false, // no-wait
		nil,   // arguments
	)
	failOnError(err, "Failed to declare a queue")
	/*
	   When the method returns, the queue instance contains a random queue name
	   generated by RabbitMQ. For example it may look like
	   amq.gen-JzTY20BRgKO-HjmUJj0wLg.

	   When the connection that declared it closes, the queue will be deleted because
	   it is declared as exclusive.

	*/
	/*
	   We've already created a fanout exchange and a queue. Now we need to tell
	   the exchange to send messages to our queue. That relationship between
	   exchange and a queue is called a binding.

	*/
	err = ch.QueueBind(
		q.Name, // queue name
		"",     // routing key
		"logs", // exchange
		false,
		nil)
	failOnError(err, "Failed to bind a queue")

	/*
	   The messages will be lost if no queue is bound to the exchange yet, but that's
	   okay for us; if no consumer is listening yet we can safely discard the message.
	*/
	msgs, err := ch.Consume(
		q.Name, // queue
		"",     // consumer
		true,   // auto-ack
		false,  // exclusive
		false,  // no-local
		false,  // no-wait
		nil,    // args
	)
	failOnError(err, "Failed to register a consumer")

	forever := make(chan bool)

	go func() {
		for d := range msgs {
			log.Printf(" [x] %s", d.Body)
		}
	}()

	log.Printf(" [*] Waiting for logs. To exit press CTRL+C")
	<-forever
}
